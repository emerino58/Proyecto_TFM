## ‚úÖ PASO 7: Aplicaci√≥n Aprendizaje Autom√°tico

import dash
from dash import html, dcc, Input, Output
import dash_bootstrap_components as dbc
import pandas as pd
import numpy as np
import plotly.express as px
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, precision_score, recall_score, f1_score

dash.register_page(__name__, path="/ml", name="Machine Learning")

# Carga y preprocesamiento
jugadores_df = pd.read_excel("data/Jugadores1A_2024.xlsx")
jugadores_df.replace("-", np.nan, inplace=True)

# Variables utilizadas para clasificaci√≥n
columnas_numericas = [
    "Duelos ganados %",
    "Duelos defensivos ganados %",
    "Duelos a√©reos ganados %",
    "Precisi√≥n centros %",
    "Regates realizados %",
    "Duelos atacantes ganados %",
    "Precisi√≥n pases %",
    "Precisi√≥n pases hacia adelante %",
    "Precisi√≥n pases hacia atr√°s %",
    "Precisi√≥n pases largos %",
    "Precisi√≥n pases en el √∫ltimo tercio %"
]

# Creamos columna de Potencial con clasificaci√≥n aleatoria inicial
np.random.seed(42)
jugadores_df["Potencial"] = np.random.choice(["Alto", "Medio", "Bajo"], size=len(jugadores_df))

# Entrenamiento inicial general del modelo (puede no usarse directamente pero lo dejamos por si acaso)
modelo_general = RandomForestClassifier(random_state=42)
modelo_general.fit(jugadores_df[columnas_numericas].fillna(0), jugadores_df["Potencial"])

# Layout
layout = dbc.Container([
    html.H2("‚öôÔ∏è An√°lisis Machine Learning del Potencial de Jugadores", className="my-3 text-center"),

    # Secci√≥n 1: Entrenamiento por Posici√≥n
    html.H4("‚úÖ Entrenamiento por posici√≥n (¬°para afinar el modelo por rol!)", className="mt-4"),
    dcc.Dropdown(
        id="posicion-dropdown",
        options=[{"label": pos, "value": pos} for pos in sorted(jugadores_df["Posici√≥n principal"].dropna().unique())],
        placeholder="Selecciona una posici√≥n...",
        className="mb-3"
    ),
    dcc.Graph(id="grafico-importancia-variables"),
    html.Div(id="tabla-metricas"),

    html.Hr(),

    # Secci√≥n 2: Mapa de calor del potencial por posici√≥n
    html.H4("üî• Mapa de calor del Potencial por Posici√≥n"),
    dcc.Graph(
        id="mapa-calor",
        figure=px.imshow(
            jugadores_df.groupby(["Posici√≥n principal", "Potencial"]).size().unstack(fill_value=0)[["Alto", "Medio", "Bajo"]],
            text_auto=True,
            color_continuous_scale="viridis_r",
            aspect="auto",
            labels=dict(x="Potencial", y="Posici√≥n principal", color="Cantidad"),
            title="Mapa de calor: Jugadores por Posici√≥n y Potencial"
        ).update_layout(template="plotly_dark", height=500)
    )
], fluid=True)

# Callback: Entrenamiento del modelo por posici√≥n
@dash.callback(
    Output("grafico-importancia-variables", "figure"),
    Output("tabla-metricas", "children"),
    Input("posicion-dropdown", "value")
)
def entrenar_modelo(posicion):
    if not posicion:
        return dash.no_update, dash.no_update

    df_pos = jugadores_df[jugadores_df["Posici√≥n principal"] == posicion]

    # Validaci√≥n de columnas
    columnas_validas = [col for col in columnas_numericas if col in df_pos.columns]
    if len(columnas_validas) < len(columnas_numericas):
        return {}, html.Div("‚ùå No se encontraron todas las variables necesarias en el dataset.")

    # Entrenamiento modelo
    X = df_pos[columnas_validas].fillna(0)
    y = df_pos["Potencial"]

    if len(X) < 10 or y.nunique() < 2:
        return {}, html.Div("‚ö†Ô∏è No hay suficientes datos para entrenar el modelo para esta posici√≥n.")

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    modelo = RandomForestClassifier(random_state=42)
    modelo.fit(X_train, y_train)
    y_pred = modelo.predict(X_test)

    # Gr√°fico de importancia
    importancias = pd.Series(modelo.feature_importances_, index=columnas_validas)
    fig_importancia = px.bar(
        importancias.sort_values(),
        orientation="h",
        labels={"value": "Importancia", "index": "Variable"},
        title=f"üéØ Importancia de variables para la posici√≥n: {posicion}",
        color=importancias.sort_values(),
        color_continuous_scale="Blues"
    )
    fig_importancia.update_layout(template="plotly_dark", height=400)

    # M√©tricas
    acc = accuracy_score(y_test, y_pred)
    prec = precision_score(y_test, y_pred, average="macro", zero_division=0)
    rec = recall_score(y_test, y_pred, average="macro", zero_division=0)
    f1 = f1_score(y_test, y_pred, average="macro", zero_division=0)

    tabla = dbc.Table([
        html.Thead(html.Tr([html.Th("M√©trica"), html.Th("Valor")])),
        html.Tbody([
            html.Tr([html.Td("Accuracy"), html.Td(f"{acc:.2f}")]),
            html.Tr([html.Td("Precision"), html.Td(f"{prec:.2f}")]),
            html.Tr([html.Td("Recall"), html.Td(f"{rec:.2f}")]),
            html.Tr([html.Td("F1-score"), html.Td(f"{f1:.2f}")])
        ])
    ], bordered=True, dark=True, hover=True, striped=True, className="mt-3")

    return fig_importancia, tabla

